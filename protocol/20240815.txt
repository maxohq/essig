

ProjectionMeta.init()
ProjectionMeta.set(module, data)
ProjectionMeta.update(module, data)
ProjectionMeta.get(module)


I would like to have a way to attach an updateable datastructure to a module name.
Use ETS tables for this. Also use `Context.current_app()` for the ETS table name, to provide namescoping based on the current_app across different ETS tables.

It should have following API:
- HandlerMeta.init(): initializes the ETS table for the current `Context.current_app()`
- HandlerMeta.set(module, data): sets the `data` for a module name (primary key)
- HandlerMeta.update(module, data): updates the `data` for a module name (primary key) (merges with existing values!)
- HandlerMeta.get(module) : get the data for a module name
- HandlerMeta.all(): returns a list of {key, data} tuples
- HandlerMeta.delete_all(): removes all values from the underlying ETS table



Now please generate a comprehensive unit test for the HandlerMeta module

---------------------------



I decided to trap exit messages:

Process.flag(:trap_exit, true)

This is the error message that I get when starting modules:

{:error,
 {:child_failure,
  {:failed_to_start_child, {"app1", Handlers.Handler1},
   {:EXIT,
    {%ArgumentError{message: "unknown registry: ChildRegistry"},
     [
       {Registry, :key_info!, 1, [file: ~c"lib/registry.ex", line: 1400]},
       {Registry, :whereis_name, 2, [file: ~c"lib/registry.ex", line: 237]},
       {:gen, :start, 6, [file: ~c"gen.erl", line: 108]},
       {:supervisor, :do_start_child_i, 3,
        [file: ~c"supervisor.erl", line: 959]},
       {:supervisor, :do_start_child, 2, [file: ~c"supervisor.erl", line: 945]},
       {:supervisor, :"-start_children/2-fun-0-", 3,
        [file: ~c"supervisor.erl", line: 929]},
       {:supervisor, :children_map, 4, [file: ~c"supervisor.erl", line: 1803]},
       {:supervisor, :init_children, 2, [file: ~c"supervisor.erl", line: 889]}
     ]}}}}}



Well, because we are using `Supervisor.start_link`, any error is thrown into the current elixir process
which terminates, when handling is not implemented. the try-rescue clause is useless in that case


This code is causing issues:

children =
    Enum.map(modules, fn module ->
      %{
        id: {app_name, module},
        start: {module, :start_link, [[]]}
      }
    end)

children |> IO.inspect(label: :children)

opts = [strategy: :one_for_one, name: supervisor_name]
{:ok, pid} = Supervisor.start_link(children, opts) |> IO.inspect()

The IEX console is restarted, without any error messages.



















I want to start a predefined set of modules under a supervisor.
The supervisor should be namescoped. The namescope name should be taken from the `Context.current_app()` function.

Example:

modules to supervise: [Handlers.Handler1, Handlers.Handler2]
name: app1


# set the global namespace token (can be accessed by child processes)
Context.set_current_app("app1")
# a (dynamic?) supervisor will be configured to run following modules, with process IDs namescoped global namespace
Starter.supervise_modules([Handlers.Handler1, Handlers.Handler2])



# it is possible to access the PIDs for each child by its module name (the namespace token is implicitly taken from the Context module)
pid1 = ChildRegistry.get(Handlers.Handler1)

GenServer.call(pid1, :all) ## should be []
GenServer.cast(pid1, {:push, 1})
GenServer.cast(pid1, {:push, 2})

GenServer.call(pid1, :all) ## should be [2,1]

# it is possible to access the PIDs for each child by its module name (the namespace token is implicitly taken from the Context module)
pid2 = ChildRegistry.get(Handlers.Handler2)

GenServer.cast(pid2, {:push, 3})
GenServer.cast(pid2, {:push, 4})
GenServer.call(pid2, :all) ## should be [4,3]


## now I set a different global namespace token
Context.set_current_app("app2")
# this starts a NEW supervision tree for given modules and they DO not conflict with the previous ones.
Starter.supervise_modules([Handlers.Handler2])


Module start should have:
- supervise_modules(modules)
  -> starts a supervisor (based on the global namespace token) + configures all children specs from the given modules list
- stop_supervisor()
  -> stops the current supervisor (based on the global namespace token)


Implement it.









